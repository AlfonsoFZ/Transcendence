‚úÖ Estructura recomendada
üß± 1. Clase base Piece y subclases

Usar POO es una buena idea para modelar el comportamiento de cada pieza.

abstract class Piece {
  constructor(public color: Color, public type: PieceType) {}

  abstract getLegalMoves(pos: Position, board: Board): Position[];
}

Y subclases para cada tipo:

class Rook extends Piece {
  constructor(color: Color) {
    super(color, 'rook');
  }

  getLegalMoves(pos: Position, board: Board): Position[] {
    // l√≥gica de torre
  }
}

üß© 2. Clase Board que contenga la l√≥gica general

class Board {
  grid: (Piece | null)[][];

  constructor() {
    this.grid = this.createInitialBoard();
  }

  movePiece(from: Position, to: Position): boolean {
    // mueve la pieza si es v√°lido
  }

  isInCheck(color: Color): boolean {
    // detecta si el rey del color dado est√° en jaque
  }

  isCheckmate(color: Color): boolean {
    // detecta si el color no puede evitar el jaque
  }

  clone(): Board {
    // para simular movimientos sin afectar el original
  }
}

‚ôüÔ∏è ¬øC√≥mo detectar jaque?

isInCheck(color: Color): boolean {
  const kingPos = this.findKing(color);
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const piece = this.grid[y][x];
      if (piece && piece.color !== color) {
        const moves = piece.getLegalMoves({ x, y }, this);
        if (moves.some(move => move.x === kingPos.x && move.y === kingPos.y)) {
          return true;
        }
      }
    }
  }
  return false;
}

üëë ¬øY jaque mate?

    Compruebas si el rey est√° en jaque.

    Simulas todos los movimientos posibles de ese jugador.

    Si ninguno elimina el jaque, entonces es jaque mate.

isCheckmate(color: Color): boolean {
  if (!this.isInCheck(color)) return false;

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const piece = this.grid[y][x];
      if (piece && piece.color === color) {
        const legalMoves = piece.getLegalMoves({ x, y }, this);
        for (const move of legalMoves) {
          const cloned = this.clone();
          cloned.movePiece({ x, y }, move);
          if (!cloned.isInCheck(color)) {
            return false; // se puede escapar del jaque
          }
        }
      }
    }
  }

  return true; // no hay salida posible
}

üß† Conclusi√≥n

    ‚úÖ S√≠, debes comprobar si el jugador actual est√° en jaque mate despu√©s de cada turno.

    ‚úÖ El enfoque m√°s robusto es simular todos los movimientos y ver si alguno elimina el jaque.

    ‚úÖ Usar una clase Board y clonar el tablero para simular es la estrategia m√°s limpia.








































üîß Parte 1: Configurar el canvas

const canvas = document.getElementById("chessboard") as HTMLCanvasElement;
const ctx = canvas.getContext("2d")!;
const squareSize = 60;

¬øQu√© hace?

    Obtiene una referencia al <canvas> con ID chessboard.

    Usa getContext("2d") para obtener el contexto de dibujo en 2D.

    Define squareSize = 60, lo que significa que cada casilla mide 60x60 p√≠xeles.

üé® Parte 2: Dibujar el tablero

function drawBoard() {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const isLight = (row + col) % 2 === 0;
      ctx.fillStyle = isLight ? "#f0d9b5" : "#b58863";
      ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
    }
  }
}

drawBoard();

¬øQu√© hace?

    Recorre todas las 64 casillas del tablero (8x8).

    Calcula si una casilla debe ser clara o oscura:

        (row + col) % 2 === 0 da un patr√≥n tipo ajedrez

    Usa ctx.fillStyle para ponerle color a cada casilla.

    Dibuja un cuadrado con fillRect(x, y, width, height).

        El x es col * squareSize

        El y es row * squareSize

    üéØ El resultado: un tablero de ajedrez visual con casillas alternadas claro/oscuro.

üñ± Parte 3: Detectar clics y convertirlos en casillas de ajedrez

canvas.addEventListener("click", (event) => {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const col = Math.floor(x / squareSize);
  const row = Math.floor(y / squareSize);

  const file = String.fromCharCode(97 + col); // a-h
  const rank = 8 - row; // 8 (arriba) a 1 (abajo)

  const squareId = `${file}${rank}`;
  console.log("Has hecho clic en:", squareId);
});

¬øQu√© hace?

    Detecta el clic en el canvas.

    Usa getBoundingClientRect() para saber la posici√≥n real del canvas en la pantalla.

    Calcula las coordenadas relativas del clic (x, y) respecto al canvas.

    Convierte esas coordenadas a √≠ndices de columna y fila (col, row).

        Divide entre el tama√±o de casilla (squareSize)

    Convierte la posici√≥n a notaci√≥n algebraica de ajedrez:

        Columna (letra) con String.fromCharCode(97 + col) ‚Üí a, b, c, ...

        Fila (n√∫mero) con 8 - row ‚Üí 8 en la fila de arriba, 1 en la de abajo

    Junta ambos y lo imprime como a1, b3, h8, etc.

üß† Ejemplo

Si haces clic en la esquina superior izquierda del canvas:

    x ‚âà 0, y ‚âà 0

    col = 0, row = 0

    file = "a", rank = 8 - 0 = 8

    Resultado: a8

Si haces clic abajo a la derecha:

    col = 7, row = 7

    file = "h", rank = 1

    Resultado: h1













































type PieceType = 'pawn' | 'rook' | 'knight' | 'bishop' | 'queen' | 'king';
type Color = 'white' | 'black';

interface Piece {
  type: PieceType;
  color: Color;
}
type Board = (Piece | null)[][];

Functions:
isValidMove
isInCheck
isCheckmate
